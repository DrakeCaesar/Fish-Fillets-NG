/*
 * Copyright (C) 2004 Ivo Danihelka (ivo@danihelka.net)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */
#include "OptionAgent.h"

#include "NameException.h"
#include "BaseMsg.h"
#include "Log.h"
#include "MessagerAgent.h"
#include "Name.h"
#include "StringMsg.h"
#include "StringTool.h"
#include "Path.h"
#include "LogicException.h"

#include <stdio.h>
#include <string.h>
#include <locale.h>

#ifndef LC_MESSAGES
#define LC_MESSAGES LC_CTYPE
#endif

//TODO: set system datadir
#ifndef SYSTEM_DATA_DIR
#define SYSTEM_DATA_DIR ""
#endif

//NOTE: userdir = $HOME + USER_DATA_DIR
#ifndef USER_DATA_DIR
#define USER_DATA_DIR "/.fillets-ng"
#endif
#ifndef USER_DATA_DIR_ALTERNATIVE
#define USER_DATA_DIR_ALTERNATIVE "/fillets-ng"
#endif

//-----------------------------------------------------------------
/**
 * Set user and sytem dir
 * and process "options.lua" - this will set user and system paths
 * and process "init.lua".
 */
    void
OptionAgent::own_init()
{
    prepareDataPaths();
    prepareLang();

    //NOTE: process system_dir options first,
    // user options will overwrite them later
    BaseMsg *msg = new StringMsg(Name::SCRIPT_NAME,
            "doall", "script/options.lua");
    MessagerAgent::agent()->forwardNewMsg(msg);

    msg = new StringMsg(Name::SCRIPT_NAME,
            "dofile", "script/init.lua");
    MessagerAgent::agent()->forwardNewMsg(msg);
}
//-----------------------------------------------------------------
/**
 * Save user config.
 * Delete left messages.
 */
    void
OptionAgent::own_shutdown()
{
    Path file = Path::dataWritePath("script/options.lua");
    FILE *config = fopen(file.getNative().c_str(), "w");
    if (config) {
        fputs("-- this file is automatically generated\n", config);

        t_values::iterator end = m_values.end();
        for (t_values::iterator i = m_values.begin(); i != end; ++i) {
            fprintf(config, "setParam(\"%s\", \"%s\")\n",
                    i->first.c_str(), i->second.c_str());
        }

        fclose(config);
    }
    else {
        LOG_WARNING(ExInfo("cannot save config")
                .addInfo("file", file.getNative()));
    }

    t_watchers::iterator end = m_watchers.end();
    for (t_watchers::iterator i = m_watchers.begin(); i != end; ++i) {
        delete i->second;
    }
}
//-----------------------------------------------------------------
/**
 * Set user and sytem dir options.
 */
void
OptionAgent::prepareDataPaths()
{
    OptionAgent::agent()->setParam("systemdir", SYSTEM_DATA_DIR);

    std::string userdir = "";
    const char *home = getenv("HOME");
    if (home) {
        userdir = home;
        userdir += USER_DATA_DIR;
        if (false == Path::isValid(userdir)) {
            userdir = home;
            userdir += USER_DATA_DIR_ALTERNATIVE;
            if (false == Path::isValid(userdir)) {
                userdir = "";
            }
            LOG_INFO(ExInfo("using alternative userdir path")
                    .addInfo("userdir", userdir)
                    .addInfo("origdir", std::string(home) + USER_DATA_DIR));
        }
    }
    OptionAgent::agent()->setParam("userdir", userdir);
}
//-----------------------------------------------------------------
/**
 * Prepare user lang option.
 * For 2-letter lang codes
 * see http://www.w3.org/WAI/ER/IG/ert/iso639.htm
 */
void
OptionAgent::prepareLang()
{
    setlocale(LC_ALL, "");
    if (getParam("lang").empty()) {
        char *form = setlocale(LC_MESSAGES, NULL);
        if (form && strlen(form) >= 2) {
            setParam("lang", std::string(form, 2));
        }
    }
}
//-----------------------------------------------------------------
/**
 * Parse command line options.
 * Format: $0 [name=value ...]
 *
 * @throws LogicException when format is wrong
 */
void
OptionAgent::parseCmdOpt(int argc, char *argv[])
{
    if (argc >= 1) {
        setParam("program", argv[0]);
    }

    for (int i = 1; i < argc; ++i) {
        std::string name;
        std::string value;
        if (splitOpt(argv[i], &name, &value)) {
            setParam(name, value);
        }
        else {
            throw LogicException(ExInfo("wrong options format")
                    .addInfo("wrong", argv[i])
                    .addInfo("usage", "$0 [name=value ...]"));
        }
    }
}
//-----------------------------------------------------------------
/**
 * Split "name=value".
 * @return true for success
 */
bool
OptionAgent::splitOpt(const std::string &option,
    std::string *out_name, std::string *out_value)
{
    bool result = false;
    std::string::size_type pos = option.find('=');
    if (pos != std::string::npos) {
        if (pos + 1  < option.size()) {
            *out_name = option.substr(0, pos);
            *out_value = option.substr(pos + 1, std::string::npos);
            result = true;
        }
    }

    return result;
}
//-----------------------------------------------------------------
/**
 * Set param.
 * Notice watchers.
 * When watcher is not available, it will be removed.
 *
 * @param name param name
 * @param value param value
 */
    void
OptionAgent::setParam(const std::string &name, const std::string &value)
{
    m_values[name] = value;
    LOG_DEBUG(ExInfo("setParam")
            .addInfo("param", name)
            .addInfo("value", value));

    t_watchers::iterator it = m_watchers.find(name);
    if (m_watchers.end() != it) {
        t_watchers::size_type count = m_watchers.count(name);
        for (t_watchers::size_type i = 0; i < count; ++i) {
            t_watchers::iterator cur_it = it++;
            try {
                cur_it->second->sendClone();
            }
            catch (NameException &e) {
                LOG_WARNING(e.info());
                delete cur_it->second;
                m_watchers.erase(cur_it);
            }
        }
    }
}
//-----------------------------------------------------------------
/**
 * Store this integer value like string param.
 */
    void
OptionAgent::setParam(const std::string &name, long value)
{
    setParam(name, StringTool::toString(value));
}
//-----------------------------------------------------------------
/**
 * Return value.
 * Implicit value is "".
 *
 * @param name param name
 * @param implicit default value = ""
 * @return value or implicit value
 */
    std::string
OptionAgent::getParam(const std::string &name,
                const std::string &implicit)
{
    std::string result = implicit;

    t_values::iterator it = m_values.find(name);
    if (m_values.end() != it) {
        result = it->second;
    }
    return result;
}
//-----------------------------------------------------------------
/**
 * Return number value.
 * Implicit value is zero.
 *
 * @param name param name
 * @param implicit default value = 0
 * @return number or implicit
 */
    int
OptionAgent::getAsInt(const std::string &name,
                int implicit)
{
    std::string value = getParam(name);
    bool ok;
    int result = StringTool::readInt(value.c_str(), &ok);
    if (false == ok) {
        result = implicit;
    }
    return result;
}
//-----------------------------------------------------------------
/**
 * Multiple watcher can watch param change.
 * @param name param name
 * @param msg message to raise
 */
    void
OptionAgent::addWatcher(const std::string &name, BaseMsg *msg)
{
    m_watchers.insert(std::pair<std::string,BaseMsg*>(name, msg));
    LOG_DEBUG(ExInfo("add watcher")
            .addInfo("param", name)
            .addInfo("msg", msg->toString()));
}


